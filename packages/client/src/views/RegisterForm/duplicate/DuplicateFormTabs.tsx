/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * OpenCRVS is also distributed under the terms of the Civil Registration
 * & Healthcare Disclaimer located at http://opencrvs.org/license.
 *
 * Copyright (C) The OpenCRVS Authors located at https://github.com/opencrvs/opencrvs-core/blob/master/AUTHORS.
 */
import * as React from 'react'
import {
  IForm,
  IFormData,
  IFormField,
  IFormFieldValue,
  IFormSection,
  IFormSectionData,
  IFormSectionGroup,
  IPreviewGroup,
  REVIEW_OVERRIDE_POSITION
} from '@client/forms'
import { useSelector } from 'react-redux'
import { getOfflineData } from '@client/offline/selectors'
import { gqlToDraftTransformer } from '@client/transformer'
import { EventType, RegStatus, History } from '@client/utils/gateway'
import { MessageDescriptor, useIntl } from 'react-intl'
import { getLanguage } from '@client/i18n/selectors'
import { getRegisterForm } from '@client/forms/register/declaration-selectors'
import { FormTabs, IFormTabs } from '@opencrvs/components/lib/FormTabs'
import { IDeclaration } from '@client/declarations'
import { EMPTY_STRING } from '@client/utils/constants'
import { Icon } from '@opencrvs/components/lib/Icon/Icon'
import { getUserDetails } from '@client/profile/profileSelectors'
import { getReviewForm } from '@client/forms/register/review-selectors'
import { ViewRecordQueries } from '@client/views/ViewRecord/query'
import {
  getErrorsOnFieldsBySection,
  IErrorsBySection,
  RequiredField
} from '@client/views/RegisterForm/review/ReviewSection'
import { getVisibleSectionGroupsBasedOnConditions } from '@client/forms/utils'
import {
  getOverriddenFieldsListForPreview,
  isViewOnly,
  isVisibleField,
  renderValue
} from '@client/views/CorrectionForm/utils'
import {
  FullBodyContent,
  Content,
  ContentSize
} from '@opencrvs/components/lib/Content'
import {
  recordAuditMessages,
  regStatusMessages
} from '@client/i18n/messages/views/recordAudit'
import styled from 'styled-components'
import { capitalize, get } from 'lodash'
import { IValidationResult } from '@client/utils/validate'
import { IFieldErrors } from '@client/forms/validation'
import { ComparisonListView } from '@opencrvs/components/lib/ComparisonListView'
import { Text } from '@opencrvs/components/lib/Text'
import { duplicateMessages } from '@client/i18n/messages/views/duplicates'
import { getName } from '@client/views/RecordAudit/utils'
import { Stack } from '@opencrvs/components/lib/Stack'
import { constantsMessages } from '@client/i18n/messages/constants'
import { SupportingDocumentsView } from '@client/views/RegisterForm/duplicate/SupportingDocumentsView'

const RightAlignedOnSmallScreen = styled(Text)`
  @media (max-width: ${({ theme }) => theme.grid.breakpoints.md}px) {
    text-align: end;
  }
`

const TopBar = styled.div`
  padding: 0 ${({ theme }) => theme.grid.margin}px;
  height: 56px;
  background: ${({ theme }) => theme.colors.white};
  border-bottom: 1px solid ${({ theme }) => theme.colors.grey300};
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  top: 0;
  width: 100%;
  position: sticky;
  z-index: 1;
`
const SupportingDocumentWrapper = styled(Stack)`
  position: sticky;
  @media (max-width: ${({ theme }) => theme.grid.breakpoints.lg}px) {
    flex-direction: column;
    align-items: flex-start;
  }
`

interface IProps {
  declaration: IDeclaration
  selectedDuplicateComId: string
  onTabClick: (id: string) => void
}

interface IComparisonDeclaration {
  title: React.ReactNode | string
  data: {
    label: React.ReactNode
    heading: {
      right: string
      left: string
    }
    rightValue: React.ReactNode
    leftValue: React.ReactNode
  }[]
}

const getVisibleSections = (
  formSections: IFormSection[],
  declaration: IDeclaration
) => {
  const draft = declaration
  return formSections.filter(
    (section) =>
      getVisibleSectionGroupsBasedOnConditions(
        section,
        draft.data[section.id] || {},
        draft.data
      ).length > 0
  )
}

function getStatusFromHistory(history: ReadonlyArray<History>) {
  return [...history]
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    .find((entry) => entry.action == null)?.regStatus as RegStatus
}

const getViewableSection = (
  registerForm: IForm,
  declaration: IDeclaration
): IFormSection[] => {
  const sections = registerForm.sections.filter(
    ({ id, viewType }) =>
      id !== 'documents' && (viewType === 'form' || viewType === 'hidden')
  )

  return getVisibleSections(sections, declaration)
}

export const DuplicateFormTabs = (props: IProps) => {
  const { selectedDuplicateComId, onTabClick } = props
  const [comparisonDelcarationData, setComparisonDelcarationData] =
    React.useState<IComparisonDeclaration[] | undefined>(undefined)

  const [duplicateDeclarationData, setDuplicateDeclarationData] =
    React.useState<IDeclaration | undefined>(undefined)
  const form = useSelector(getReviewForm)
  const userDetails = useSelector(getUserDetails)
  const language = useSelector(getLanguage)
  const offlineData = useSelector(getOfflineData)
  const registerForm = useSelector(getRegisterForm)
  const intl = useIntl()

  const getFieldValueWithErrorMessage = (
    section: IFormSection,
    field: IFormField,
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    errorsOnField: any
  ) => {
    return (
      <RequiredField id={`required_label_${section.id}_${field.name}`}>
        {field.ignoreFieldLabelOnErrorMessage ||
          (field.previewGroup && intl.formatMessage(field.label) + ' ')}
        {intl.formatMessage(errorsOnField.message, errorsOnField.props)}
      </RequiredField>
    )
  }

  const getErrorForNestedField = (
    section: IFormSection,
    field: IFormField,
    sectionErrors: IErrorsBySection
  ): IValidationResult[] => {
    for (const key in sectionErrors[section.id]) {
      return sectionErrors[section.id][key].nestedFields[field.name] || []
    }
    return []
  }

  const getValueOrError = (
    section: IFormSection,
    data: IFormData,
    field: IFormField,
    sectionErrors: IErrorsBySection,
    ignoreNestedFieldWrapping?: boolean,
    replaceEmpty?: boolean
  ) => {
    let value = renderValue(
      data,
      section.id,
      field,
      intl,
      offlineData,
      language
    )

    if (replaceEmpty && !value) {
      value = '-'
    }
    const errorsOnField =
      get(sectionErrors[section.id][field.name], 'errors') ||
      getErrorForNestedField(section, field, sectionErrors)

    return errorsOnField.length > 0
      ? getFieldValueWithErrorMessage(section, field, errorsOnField[0])
      : field.nestedFields && !Boolean(ignoreNestedFieldWrapping)
        ? (
            (data[section.id] &&
              data[section.id][field.name] &&
              (data[section.id][field.name] as IFormSectionData).value &&
              field.nestedFields[
                (data[section.id][field.name] as IFormSectionData)
                  .value as string
              ]) ||
            []
          ).reduce(
            (groupedValues, nestedField) => {
              const errorsOnNestedField =
                sectionErrors[section.id][field.name].nestedFields[
                  nestedField.name
                ] || []
              // Value of the parentField resembles with IFormData as a nested form
              const nestedValue =
                (data[section.id] &&
                  data[section.id][field.name] &&
                  renderValue(
                    data[section.id][field.name] as IFormData,
                    'nestedFields',
                    nestedField,
                    intl,
                    offlineData,
                    language
                  )) ||
                ''
              return (
                <>
                  {groupedValues}
                  {(errorsOnNestedField.length > 0 || nestedValue) && <br />}
                  {errorsOnNestedField.length > 0
                    ? getFieldValueWithErrorMessage(
                        section,
                        field,
                        errorsOnNestedField[0]
                      )
                    : nestedValue}
                </>
              )
            },
            <>{value}</>
          )
        : value
  }

  const getRenderableField = (
    {
      fieldLabel,
      fieldLabelParams
    }: {
      fieldLabel: MessageDescriptor
      fieldLabelParams?: Record<string, string>
    },
    value: IFormFieldValue | JSX.Element | undefined
  ) => {
    return {
      label: intl.formatMessage(fieldLabel, fieldLabelParams),
      value
    }
  }

  const getSinglePreviewField = (
    declaration: IDeclaration,
    section: IFormSection,
    field: IFormField,
    sectionErrors: IErrorsBySection,
    ignoreNestedFieldWrapping?: boolean
  ) => {
    const { data } = declaration

    const value = getValueOrError(
      section,
      data,
      field,
      sectionErrors,
      ignoreNestedFieldWrapping
    )

    return getRenderableField(
      { fieldLabel: field.label, fieldLabelParams: field.labelParam },
      value
    )
  }

  const getPreviewGroupsField = (
    section: IFormSection,
    group: IFormSectionGroup,
    field: IFormField,
    visitedTags: string[],
    errorsOnFields: IErrorsBySection,
    declaration: IDeclaration
  ) => {
    const draft = declaration

    if (field.previewGroup && !visitedTags.includes(field.previewGroup)) {
      visitedTags.push(field.previewGroup)

      const baseTag = field.previewGroup
      const taggedFields: IFormField[] = []
      group.fields.forEach((field) => {
        if (
          isVisibleField(
            field,
            section,
            declaration,
            offlineData,
            userDetails
          ) &&
          !isViewOnly(field)
        ) {
          if (field.previewGroup === baseTag) {
            taggedFields.push(field)
          }
          for (const index in field.nestedFields) {
            field.nestedFields[index].forEach((tempField) => {
              if (
                isVisibleField(
                  tempField,
                  section,
                  declaration,
                  offlineData,
                  userDetails
                ) &&
                !isViewOnly(tempField) &&
                tempField.previewGroup === baseTag
              ) {
                taggedFields.push(tempField)
              }
            })
          }
        }
      })

      const tagDef =
        (group.previewGroups &&
          (group.previewGroups.filter(
            (previewGroup) => previewGroup.id === baseTag
          ) as IPreviewGroup[])) ||
        []
      const values = taggedFields
        .map((field) =>
          getValueOrError(section, draft.data, field, errorsOnFields)
        )
        .filter((value) => value)

      let completeValue = values[0]
      values.shift()
      values.forEach(
        (value) =>
          (completeValue = (
            <>
              {completeValue}
              {tagDef[0].delimiter ? (
                <span>{tagDef[0].delimiter}</span>
              ) : (
                <br />
              )}
              {value}
            </>
          ))
      )

      return getRenderableField(
        {
          fieldLabel: (tagDef[0] && tagDef[0].label) || field.label,
          fieldLabelParams: field.labelParam
        },
        completeValue
      )
    }
  }

  const getNestedFieldValueOrError = (
    section: IFormSection,
    nestSectionData: IFormData,
    nestedField: IFormField,
    parentFieldErrors: IFieldErrors
  ) => {
    const errorsOnNestedField =
      parentFieldErrors.nestedFields[nestedField.name] || []

    return (
      <>
        {errorsOnNestedField.length > 0
          ? getFieldValueWithErrorMessage(
              section,
              nestedField,
              errorsOnNestedField[0]
            )
          : renderValue(
              nestSectionData,
              'nestedFields',
              nestedField,
              intl,
              offlineData,
              language
            )}
      </>
    )
  }

  const getNestedPreviewField = (
    section: IFormSection,
    group: IFormSectionGroup,
    field: IFormField,
    sectionErrors: IErrorsBySection,
    declaration: IDeclaration
  ) => {
    const draft = declaration
    const visitedTags: string[] = []
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    const nestedItems: any[] = []
    // parent field
    nestedItems.push(
      getSinglePreviewField(declaration, section, field, sectionErrors, true)
    )
    ;(
      (field.nestedFields &&
        draft.data[section.id] &&
        draft.data[section.id][field.name] &&
        (draft.data[section.id][field.name] as IFormSectionData).value &&
        field.nestedFields[
          (draft.data[section.id][field.name] as IFormSectionData)
            .value as string
        ]) ||
      []
    ).forEach((nestedField) => {
      if (nestedField.previewGroup) {
        nestedItems.push(
          getPreviewGroupsField(
            section,
            group,
            nestedField,
            visitedTags,
            sectionErrors,
            declaration
          )
        )
      } else {
        nestedItems.push(
          getRenderableField(
            {
              fieldLabel: nestedField.label,
              fieldLabelParams: nestedField.labelParam
            },
            getNestedFieldValueOrError(
              section,
              draft.data[section.id][field.name] as IFormData,
              nestedField,
              sectionErrors[section.id][field.name]
            )
          )
        )
      }
    })
    return nestedItems
  }

  const getOverRiddenPreviewField = (
    declaration: IDeclaration,
    section: IFormSection,
    group: IFormSectionGroup,
    overriddenField: IFormField,
    sectionErrors: IErrorsBySection,
    field: IFormField,
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    items: any[],
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    item: any
  ) => {
    overriddenField.label =
      get(overriddenField, 'reviewOverrides.labelAs') || overriddenField.label
    const residingSectionId = get(
      overriddenField,
      'reviewOverrides.residingSection'
    )
    const residingSection = registerForm.death.sections.find(
      (section) => section.id === residingSectionId
    ) as IFormSection

    const result = getSinglePreviewField(
      declaration,
      residingSection,
      overriddenField,
      sectionErrors
    )

    const { sectionID, groupID, fieldName } =
      overriddenField!.reviewOverrides!.reference
    if (
      sectionID === section.id &&
      groupID === group.id &&
      fieldName === field.name
    ) {
      if (
        overriddenField!.reviewOverrides!.position ===
        REVIEW_OVERRIDE_POSITION.BEFORE
      ) {
        items = items.concat(result)
        items = items.concat(item)
      } else {
        items = items.concat(item)
        items = items.concat(result)
      }
      return items
    }

    items = items.concat(item)
    return items
  }

  const transformSectionData = (
    formSections: IFormSection[],
    errorsOnFields: IErrorsBySection,
    declaration: IDeclaration
  ) => {
    const draft = declaration
    const overriddenFields = getOverriddenFieldsListForPreview(
      formSections,
      declaration,
      offlineData,
      userDetails
    )
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    let tempItem: any
    return formSections.map((section) => {
      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
      let items: any[] = []
      const visitedTags: string[] = []
      const visibleGroups = getVisibleSectionGroupsBasedOnConditions(
        section,
        draft.data[section.id] || {},
        draft.data
      )
      visibleGroups.forEach((group) => {
        group.fields
          .filter(
            (field) =>
              isVisibleField(
                field,
                section,
                declaration,
                offlineData,
                userDetails
              ) && !isViewOnly(field)
          )
          .filter((field) => !Boolean(field.hideInPreview))
          .filter((field) => !Boolean(field.reviewOverrides))
          .forEach((field) => {
            tempItem = field.previewGroup
              ? getPreviewGroupsField(
                  section,
                  group,
                  field,
                  visitedTags,
                  errorsOnFields,
                  declaration
                )
              : field.nestedFields && field.ignoreNestedFieldWrappingInPreview
                ? getNestedPreviewField(
                    section,
                    group,
                    field,
                    errorsOnFields,
                    declaration
                  )
                : getSinglePreviewField(draft, section, field, errorsOnFields)

            overriddenFields.forEach((overriddenField) => {
              items = getOverRiddenPreviewField(
                draft,
                section,
                group,
                overriddenField as IFormField,
                errorsOnFields,
                field,
                items,
                tempItem
              )
            })

            if (!overriddenFields.length) {
              items = items.concat(tempItem)
            }
          })
      })
      return {
        id: section.id,
        title: section.title ? intl.formatMessage(section.title) : '',
        items: items.filter((item) => item)
      }
    })
  }

  const fetchDuplicateDeclaration = async (duplicateCompositionId: string) => {
    return await ViewRecordQueries.fetchDeclarationForViewing(
      duplicateCompositionId
    )
  }

  const tabs: IFormTabs[] =
    props.declaration.duplicates?.map((duplicateId) => {
      return {
        id: duplicateId.compositionId,
        title: duplicateId.trackingId,
        disabled: false
      }
    }) ?? []

  tabs.unshift({
    id: props.declaration.id,
    title: (props.declaration.data.registration.trackingId as string) || '',
    disabled: false,
    icon: <Icon name="WarningCircle" color="red" size="medium" />,
    color: 'red'
  })

  const actualTrackingId = tabs[0].title
  const duplicateTrackingId = tabs.find(
    (tab) => tab.id === selectedDuplicateComId
  )?.title as string

  const duplicateTabHandler = async (duplicateCompositionId: string) => {
    if (String(props.declaration.id) !== duplicateCompositionId) {
      const duplicateDeclarationGQLData = await fetchDuplicateDeclaration(
        duplicateCompositionId
      )
      const eventData =
        duplicateDeclarationGQLData?.data?.fetchRegistrationForViewing
      const eventType =
        duplicateDeclarationGQLData?.data?.fetchRegistrationForViewing?.registration.type.toLowerCase() as EventType
      const duplicateDeclarationData = gqlToDraftTransformer(
        form[eventType],
        eventData,
        offlineData,
        userDetails!
      )
      setDuplicateDeclarationData({
        data: duplicateDeclarationData
      } as IDeclaration)

      const actualDeclarationFormSections = getViewableSection(
        registerForm[eventType],
        props.declaration
      )
      const actualDeclarationerrorsOnFields = getErrorsOnFieldsBySection(
        actualDeclarationFormSections,
        offlineData,
        props.declaration,
        userDetails
      )
      const actualDeclarationTransformData = transformSectionData(
        actualDeclarationFormSections,
        actualDeclarationerrorsOnFields,
        props.declaration
      )

      const duplicateDeclarationFormSections = getViewableSection(
        registerForm[eventType],
        { data: duplicateDeclarationData } as IDeclaration
      )
      const duplicateDeclarationerrorsOnFields = getErrorsOnFieldsBySection(
        duplicateDeclarationFormSections,
        offlineData,
        { data: duplicateDeclarationData } as IDeclaration,
        userDetails
      )
      const duplicateDeclarationTransformData = transformSectionData(
        duplicateDeclarationFormSections,
        duplicateDeclarationerrorsOnFields,
        { data: duplicateDeclarationData } as IDeclaration
      )

      const duplicateRegData = {
        status: getStatusFromHistory(eventData.history),
        type: capitalize(eventData.registration.type),
        trackingId: eventData.registration.trackingId,
        registrationNumber: eventData.registration?.registrationNumber,
        registeredAt: (eventData.history as History[]).find(
          (data) =>
            data.action === null && data.regStatus === RegStatus.Registered
        )?.office?.name,
        registeredBy: getName(
          (eventData.history as History[]).find(
            (data) =>
              data.action === null && data.regStatus === RegStatus.Registered
          )?.user?.name ?? [],
          language
        )
      }

      const actualRegData = {
        status: props.declaration.registrationStatus,
        type: capitalize(String(props.declaration.data.registration.type)),
        trackingId: props.declaration.data.registration.trackingId,
        registrationNumber:
          props.declaration.data.registration?.registrationNumber,
        registeredAt: (
          props.declaration.data.history as unknown as History[]
        ).find(
          (data) =>
            data.action === null && data.regStatus === RegStatus.Registered
        )?.office?.name,
        registeredBy: getName(
          (props.declaration.data.history as unknown as History[]).find(
            (data) =>
              data.action === null && data.regStatus === RegStatus.Registered
          )?.user?.name ?? [],
          language
        )
      }

      const registrationComparisonData = [
        {
          label: (
            <Text variant="bold16" element="span" color="grey600">
              {intl.formatMessage(constantsMessages.status)}
            </Text>
          ),

          heading: {
            right: String(duplicateRegData.trackingId),
            left: String(actualRegData.trackingId)
          },
          leftValue: (
            <Text variant="reg16" element="span" color="grey600">
              {actualRegData.status
                ? intl.formatMessage(regStatusMessages[actualRegData.status])
                : EMPTY_STRING}
            </Text>
          ),
          rightValue: (
            <Text variant="reg16" element="span" color="grey600">
              {duplicateRegData.status
                ? intl.formatMessage(regStatusMessages[duplicateRegData.status])
                : EMPTY_STRING}
            </Text>
          )
        },
        {
          label: (
            <Text variant="bold16" element="span" color="grey600">
              {intl.formatMessage(constantsMessages.eventType)}
            </Text>
          ),
          heading: {
            right: String(duplicateRegData.trackingId),
            left: String(actualRegData.trackingId)
          },
          leftValue: (
            <Text variant="reg16" element="span" color="grey600">
              {actualRegData.type}
            </Text>
          ),
          rightValue: (
            <Text variant="reg16" element="span" color="grey600">
              {duplicateRegData.type}
            </Text>
          )
        },
        {
          label: (
            <Text variant="bold16" element="span" color="grey600">
              {intl.formatMessage(constantsMessages.trackingId)}
            </Text>
          ),
          heading: {
            right: String(duplicateRegData.trackingId),
            left: String(actualRegData.trackingId)
          },
          leftValue: (
            <Text variant="reg16" element="span" color="grey600">
              {actualRegData.trackingId as string}
            </Text>
          ),
          rightValue: (
            <Text variant="reg16" element="span" color="grey600">
              {duplicateRegData.trackingId}
            </Text>
          )
        },
        {
          label: (
            <Text variant="bold16" element="span" color="grey600">
              {intl.formatMessage(recordAuditMessages.rn)}
            </Text>
          ),
          heading: {
            right: String(duplicateRegData.trackingId),
            left: String(actualRegData.trackingId)
          },
          leftValue: (
            <Text variant="reg16" element="span" color="grey600">
              {actualRegData.registrationNumber as string}
            </Text>
          ),
          rightValue: (
            <Text variant="reg16" element="span" color="grey600">
              {duplicateRegData.registrationNumber}
            </Text>
          )
        },
        {
          label: (
            <Text variant="bold16" element="span" color="grey600">
              {intl.formatMessage(constantsMessages.registeredAt)}
            </Text>
          ),
          heading: {
            right: String(duplicateRegData.trackingId),
            left: String(actualRegData.trackingId)
          },
          leftValue: (
            <Text variant="reg16" element="span" color="grey600">
              {actualRegData.registeredAt}
            </Text>
          ),
          rightValue: (
            <Text variant="reg16" element="span" color="grey600">
              {duplicateRegData.registeredAt}
            </Text>
          )
        },
        {
          label: (
            <Text variant="bold16" element="span" color="grey600">
              {intl.formatMessage(constantsMessages.registeredBy)}
            </Text>
          ),
          heading: {
            right: String(duplicateRegData.trackingId),
            left: String(actualRegData.trackingId)
          },
          leftValue: (
            <Text variant="reg16" element="span" color="grey600">
              {actualRegData.registeredBy}
            </Text>
          ),
          rightValue: (
            <Text variant="reg16" element="span" color="grey600">
              {duplicateRegData.registeredBy}
            </Text>
          )
        }
      ]
      const formatterComparisonData = actualDeclarationTransformData.map(
        (data1) => {
          const data2 = duplicateDeclarationTransformData.find(
            (d) => d.id === data1.id
          )
          return {
            title: data1.title,
            data: data1.items.map((item1) => {
              const item2 = data2?.items.find((i) => i.label === item1.label)
              return {
                label: (
                  <Text variant="bold16" element="span" color="grey600">
                    {item1.label}
                  </Text>
                ),
                heading: {
                  right: String(duplicateRegData.trackingId),
                  left: String(actualRegData.trackingId)
                },
                leftValue: (
                  <Text variant="reg16" element="span" color="grey600">
                    {item1.value}
                  </Text>
                ),
                rightValue: (
                  <Text variant="reg16" element="span" color="grey600">
                    {item2?.value}
                  </Text>
                )
              }
            })
          }
        }
      )
      formatterComparisonData[0].data.push(...registrationComparisonData)
      setComparisonDelcarationData(formatterComparisonData)
    } else {
      setComparisonDelcarationData(undefined)
    }
    onTabClick(duplicateCompositionId)
  }

  return (
    <>
      <TopBar>
        <FormTabs
          sections={tabs}
          activeTabId={selectedDuplicateComId || EMPTY_STRING}
          onTabClick={async (id: string) => await duplicateTabHandler(id)}
        />
      </TopBar>

      {comparisonDelcarationData && (
        <FullBodyContent>
          <div>
            <Content
              title={intl.formatMessage(
                duplicateMessages.duplicateComparePageTitle,
                {
                  actualTrackingId: (
                    <Text variant="bold18" element="span" color="negative">
                      {actualTrackingId}
                    </Text>
                  ),
                  duplicateTrackingId
                }
              )}
              size={ContentSize.LARGE}
              showTitleOnMobile
            >
              <Text element="h1" variant="h4" align="left" id="title-text">
                {intl.formatMessage(
                  duplicateMessages.duplicateDeclarationDetails
                )}
              </Text>
              <Stack direction="column" gap={20} alignItems={'stretch'}>
                {comparisonDelcarationData.map((sections, index) => {
                  return (
                    <div key={`comparison-div-${index}`}>
                      <Text variant="bold18" element="span" color="grey600">
                        {sections.title}
                      </Text>
                      <ComparisonListView
                        headings={[actualTrackingId, duplicateTrackingId]}
                        key={`comparison-${index}`}
                      >
                        {sections.data.map((item, index) => (
                          <ComparisonListView.Row
                            label={item.label}
                            heading={{
                              right: item.heading.right,
                              left: item.heading.left
                            }}
                            leftValue={
                              <RightAlignedOnSmallScreen
                                variant="reg16"
                                element="span"
                              >
                                {item.leftValue}
                              </RightAlignedOnSmallScreen>
                            }
                            rightValue={
                              <RightAlignedOnSmallScreen
                                variant="reg16"
                                element="span"
                              >
                                {item.rightValue}
                              </RightAlignedOnSmallScreen>
                            }
                            key={`row-${index}`}
                          />
                        ))}
                      </ComparisonListView>
                    </div>
                  )
                })}
              </Stack>
            </Content>
          </div>
          <div>
            <Content
              title={intl.formatMessage(
                duplicateMessages.duplicateComparePageSupportingDocuments
              )}
              size={ContentSize.LARGE}
              showTitleOnMobile
            >
              <SupportingDocumentWrapper
                justifyContent={'space-between'}
                gap={25}
              >
                <div style={{ flex: 1 }}>
                  <Text variant="bold14" element="p" color="redDark">
                    {actualTrackingId}
                  </Text>
                  <SupportingDocumentsView declaration={props.declaration} />
                </div>
                <div style={{ flex: 1 }}>
                  <Text variant="bold14" element="p" color="grey400">
                    {duplicateTrackingId}
                  </Text>
                  <SupportingDocumentsView
                    declaration={duplicateDeclarationData as IDeclaration}
                  />
                </div>
              </SupportingDocumentWrapper>
            </Content>
          </div>
        </FullBodyContent>
      )}
    </>
  )
}
