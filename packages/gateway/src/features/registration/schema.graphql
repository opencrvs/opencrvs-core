enum RegStatus {
  DECLARED
  REGISTERED
  CERTIFIED
}

enum BirthRegType {
  BOTH_PARENTS
  SELF
  INFORMANT_ONLY
  MOTHER_ONLY
  FATHER_ONLY
}

enum RegistrationContactType {
  MOTHER
  FATHER
}

enum BirthRegPresence {
  BOTH_PARENTS
  INFORMANT_ONLY
  MOTHER_ONLY
  FATHER_ONLY
  OTHER
}

enum BirthType {
  SINGLE
  TWIN
  TRIPLET
  QUADRUPLET
  HIGHER_MULTIPLE_DELIVERY
}

enum AttendantType {
  PHYSICIAN
  NURSE
  NURSE_MIDWIFE
  MIDWIFE
  OTHER_PARAMEDICAL_PERSONNEL
  LAYPERSON
  NONE
  OTHER
}

enum AttachmentType {
  PASSPORT
  NATIONAL_ID
  IMMUNISATION_CERTIFICATE
  PAPER_FORM
  PASSPORT_PHOTO
  BIRTH_REGISTRATION
  SCHOOL_CERTIFICATE
  OTHER
}

enum AttachmentSubject {
  MOTHER
  FATHER
  CHILD
  OTHER
}

enum RegistrationType {
  BIRTH
  DEATH
}

enum CauseOfDeath {
  NATURAL
  ACCIDENT
  OTHER
}

input CommentInput {
  user: UserInput
  comment: String
  createdAt: Date
}

type Comment { # Annotation
  id: ID!
  user: User # -> .authorString
  comment: String # -> .text
  createdAt: Date # -> .time
}

input RegWorkflowInput {
  type: RegStatus
  user: UserInput
  timestamp: Date
  comments: [CommentInput]
  location: LocationInput
}

type RegWorkflow { # Task
  id: ID!
  type: RegStatus # -> .businessStatus
  user: User # -> extension(url='http://opencrvs.org/specs/extension/regLastUser').valueReference
  timestamp: Date # -> lastModified
  comments: [Comment] # -> .note
  location: Location # -> extension(url='http://opencrvs.org/specs/extension/regLastLocation').valueReference
}

input CertificateInput {
  paperId: ID!
  reciever: PersonInput
  location: LocationInput
  User: UserInput
  createdAt: Date
}

type Certificate { # In manual register system (signature) not in BDRIS2
  id: ID!
  paperId: ID!
  reciever: Person
  location: Location
  User: User
  createdAt: Date
}

input BirthRegistrationInput {
  _fhirIDMap: Map
  registration: RegistrationInput
  child: PersonInput
  mother: PersonInput
  father: PersonInput
  informant: PersonInput
  birthLocation: LocationInput
  birthType: BirthType # Not in BDRIS2
  weightAtBirth: Float # Not in BDRIS2
  attendantAtBirth: AttendantType # Not in BDRIS2
  birthRegistrationType: BirthRegType
  presentAtBirthRegistration: BirthRegPresence # Informant in BDRIS2
  childrenBornAliveToMother: Int # Not in BDRIS2
  foetalDeathsToMother: Int # Not in BDRIS2
  lastPreviousLiveBirth: Date # Not in BDRIS2
  # For order of birth 3 equals 3rd born - remember to also save to Person multipleBirth field
  birthOrder: Int
  createdAt: Date
  updatedAt: Date
}

type BirthRegistration { # -> Composition
  id: ID! # long uuid
  _fhirIDMap: Map
  registration: Registration
  child: Person # -> .section(code='child-details').entry.reference
  mother: Person # -> .section(code='mother-details').entry.reference
  father: Person # -> .section(code='father-details').entry.reference
  informant: Person # -> .section(code='informant-details').entry.reference
  birthLocation: Location # -> .section(code='birth-encounter').entry.reference.location
  birthType: BirthType # -> Observation.valueInteger
  weightAtBirth: Float # -> Observation.valueQuantity (code=kg)
  attendantAtBirth: AttendantType # -> Observation.valueString
  birthRegistrationType: BirthRegType # -> Observation.valueString
  presentAtBirthRegistration: BirthRegPresence # -> Observation.valueString
  childrenBornAliveToMother: Int # -> Observation.valueInteger
  foetalDeathsToMother: Int # -> Observation.valueInteger
  lastPreviousLiveBirth: Date # -> Observation.valueDateTime
  # For order of birth 3 equals 3rd born - remember to also save to Person multipleBirth field
  birthOrder: Int # -> Patient.multipleBirthInteger
  createdAt: Date # -> .date($first)
  updatedAt: Date # -> .date
}

input DeathRegistrationInput {
  registration: RegistrationInput
  # Remember to mark person as deceased
  deceased: PersonInput
  mother: PersonInput
  father: PersonInput
  informant: PersonInput
  # need to track multiple spouses for muslim countries
  spouse: [PersonInput]
  deathLocation: LocationInput
  causeOfDeath: CauseOfDeath # need to store ICD-10? More types of cause of death
  createdAt: Date
  updatedAt: Date
}

# In BDRIS2 BRN is used to link to birth - Must have BRN to register death. Only deathLocation and current address is captures for death as the rest is the same as birth registration
type DeathRegistration { # -> Composition
  id: ID! # long uuid
  registration: Registration
  # Remember to mark person as deceased
  deceased: Person # -> .section(code='deceased-details').entry.reference
  mother: Person # -> .section(code='mother-details').entry.reference - create link to existing?
  father: Person # -> .section(code='fater-details').entry.reference - create link to existing?
  informant: Person # -> .section(code='informant-details').entry.reference
  # need to track multiple spouses for muslim countries
  spouse: [Person] # -> .section(code='spouse-details').entry.reference # Not in BDRIS2
  deathLocation: Location # -> .section(code='death-encounter').entry.reference.location
  causeOfDeath: CauseOfDeath # -> Observation.valueCodeableConcept
  createdAt: Date # -> .date($first)
  updatedAt: Date # -> .date
}

input RegistrationInput {
  _fhirID: ID
  # short uuid easy to remember
  trackingId: String
  # BRN (Birth Registration Number) DRN (Death Registration Number) - Format to be decided
  registrationNumber: String
  paperFormID: String
  page: String
  book: String
  contact: RegistrationContactType # -> extension(url='http://opencrvs.org/specs/extension/contact-person').valueString
  status: [RegWorkflowInput]
  type: RegistrationType
  attachments: [AttachmentInput]
  location: LocationInput
}

type Registration { # -> Task
  _fhirID: ID # -> .id
  # short uuid easy to remember
  trackingId: String # -> .identifier
  # BRN (Birth Registration Number) DRN (Death Registration Number) - Format to be decided
  registrationNumber: String # -> .identifier
  paperFormID: String # -> .identifier
  page: String # -> .identifier
  book: String # -> .identifier
  contact: RegistrationContactType # -> extension(url='http://opencrvs.org/specs/extension/contact-person').valueString
  status: [RegWorkflow] # -> Task.*
  type: RegistrationType # -> .code
  attachments: [Attachment] # -> Composition.section(code='scanned-documents').entry.reference
  duplicates: [ID]
}

input AttachmentInput {
  _fhirID: ID
  contentType: String
  # base64
  data: String
  # approved/validated/deleted
  status: String
  originalFileName: String
  systemFileName: String
  type: AttachmentType
  subject: AttachmentSubject
  createdAt: Date
}

type Attachment { # -> DocumentReference
  id: ID! # uuid
  _fhirID: ID # -> .id
  contentType: String # -> .content.attachment.contentType
  # base64
  data: String # -> .content.attachment.data base64
  # approved/validated/deleted
  status: String # -> .status
  originalFileName: String # -> .identifier
  systemFileName: String # -> .identifier
  type: AttachmentType # -> .type
  subject: AttachmentSubject # -> .subject (convert this to a reference to the person resoure in FHIR)
  createdAt: Date # -> .created
}

type Query {
  fetchBirthRegistration(id: ID!): BirthRegistration
  listBirthRegistrations(
    locationIds: [String]
    status: String
    userId: String
    from: Date
    to: Date
  ): [BirthRegistration]
  listDeathRegistrations(
    locationIds: [String]
    status: String
    userId: String
    from: Date
    to: Date
  ): [BirthRegistration]
}

type Mutation {
  # BIRTH
  createBirthRegistration(details: BirthRegistrationInput!): ID!
  updateBirthRegistration(id: ID!, details: BirthRegistrationInput!): ID!
  # process transitions
  markBirthAsVerified(
    id: ID!
    details: BirthRegistrationInput
  ): BirthRegistration # updates status to 'verified' + audit? - attachments are valid and in order, ready for registration - internally call update if details exists
  markBirthAsRegistered(id: ID!, details: BirthRegistrationInput): ID! # updates status to 'registered' - registration clerk has accepted the declaration, it is now official - internally call update if details exists
  markBirthAsCertified(
    id: ID!
    details: BirthRegistrationInput
  ): BirthRegistration # updates status to 'certified' - a printed certificate has been produced - internally call update if details exists
  markBirthAsVoided(id: String!, reason: String!, comment: String): ID! # updated status to 'voided' - the registration was captured in error
  # DEATH
  createDeathRegistration(details: DeathRegistrationInput!): ID!
  updateDeathRegistration(
    id: ID!
    details: DeathRegistrationInput!
  ): DeathRegistration!
  # process transitions
  markDeathAsVerified(id: ID!, location: LocationInput): DeathRegistration # updates status to 'verified' + audit? - attachments are valid and in order, ready for registration
  markDeathAsRegistered(id: ID!, location: LocationInput): DeathRegistration # updates status to 'registered' - registration clerk has accepted the declaration, it is now official
  markDeathAsCertified(id: ID!, location: LocationInput): DeathRegistration # updates status to 'certified' - a printed certificate has been produced
  markDeathAsVoided(
    id: ID!
    reason: String!
    location: LocationInput
  ): DeathRegistration # updated status to 'voided' - the registration was captured in error
}
